---
title: 002 处理表格大量数据渲染问题
theme: solarized-dark
---

# 处理表格大量数据渲染问题

## 问题背景

在开发列表系统时，初期几十条数据表现良好，但随着业务发展，一页需要展示几百行、几十列的数据，包含图片、状态标签、各种操作按钮等复杂元素，用户反馈卡顿严重。这是典型的大数据量渲染性能问题。

## 性能问题分析

### **主要性能瓶颈**

1. **DOM 节点过多** - 大量 DOM 元素导致浏览器渲染负担重
2. **内存占用高** - 所有数据同时加载到内存
3. **重复渲染** - 不必要的组件重新渲染
4. **资源加载** - 大量图片同时加载
5. **事件监听器过多** - 每行都有多个操作按钮

### **性能指标检测**

```javascript
// 性能监控代码
function measurePerformance() {
  const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      console.log(`${entry.name}: ${entry.duration}ms`);
    }
  });

  observer.observe({ entryTypes: ['measure', 'navigation'] });

  // 测量渲染时间
  performance.mark('render-start');
  // ... 渲染代码
  performance.mark('render-end');
  performance.measure('render-time', 'render-start', 'render-end');
}
```

> **总结**：通过性能分析工具识别具体的性能瓶颈，为优化提供数据支撑。

## 核心优化策略

### 1. **虚拟滚动（Virtual Scrolling）**

虚拟滚动是解决大数据量渲染的核心技术，只渲染可视区域内的数据。

```javascript
// React 虚拟滚动实现示例
import React, { useState, useEffect, useRef } from 'react';

const VirtualTable = ({ data, rowHeight = 50, containerHeight = 400 }) => {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef(null);

  // 计算可视区域
  const startIndex = Math.floor(scrollTop / rowHeight);
  const endIndex = Math.min(startIndex + Math.ceil(containerHeight / rowHeight) + 1, data.length);

  // 可视区域数据
  const visibleData = data.slice(startIndex, endIndex);

  const handleScroll = (e) => {
    setScrollTop(e.target.scrollTop);
  };

  return (
    <div
      ref={containerRef}
      style={{
        height: containerHeight,
        overflow: 'auto',
        position: 'relative',
      }}
      onScroll={handleScroll}
    >
      {/* 占位容器，维持滚动条高度 */}
      <div style={{ height: data.length * rowHeight, position: 'relative' }}>
        {/* 可视区域内容 */}
        <div
          style={{
            position: 'absolute',
            top: startIndex * rowHeight,
            width: '100%',
          }}
        >
          {visibleData.map((item, index) => (
            <TableRow key={startIndex + index} data={item} style={{ height: rowHeight }} />
          ))}
        </div>
      </div>
    </div>
  );
};
```

> **总结**：虚拟滚动通过只渲染可视区域元素，将 DOM 节点数量从数千个降低到几十个，显著提升性能。

### 2. **分页和懒加载**

```javascript
// 智能分页策略
class SmartPagination {
  constructor(options = {}) {
    this.pageSize = options.pageSize || 50;
    this.preloadPages = options.preloadPages || 1;
    this.cache = new Map();
    this.loading = new Set();
  }

  async loadPage(pageNum, forceRefresh = false) {
    const cacheKey = `page_${pageNum}`;

    // 检查缓存
    if (this.cache.has(cacheKey) && !forceRefresh) {
      return this.cache.get(cacheKey);
    }

    // 防止重复加载
    if (this.loading.has(pageNum)) {
      return new Promise((resolve) => {
        const checkLoading = () => {
          if (!this.loading.has(pageNum)) {
            resolve(this.cache.get(cacheKey));
          } else {
            setTimeout(checkLoading, 100);
          }
        };
        checkLoading();
      });
    }

    this.loading.add(pageNum);

    try {
      const data = await this.fetchData(pageNum);
      this.cache.set(cacheKey, data);

      // 预加载相邻页面
      this.preloadAdjacentPages(pageNum);

      return data;
    } finally {
      this.loading.delete(pageNum);
    }
  }

  async preloadAdjacentPages(currentPage) {
    const promises = [];
    for (let i = 1; i <= this.preloadPages; i++) {
      // 预加载前后页面
      if (currentPage - i > 0) {
        promises.push(this.loadPage(currentPage - i));
      }
      promises.push(this.loadPage(currentPage + i));
    }

    // 不等待预加载完成
    Promise.allSettled(promises);
  }

  async fetchData(pageNum) {
    const response = await fetch(`/api/data?page=${pageNum}&size=${this.pageSize}`);
    return response.json();
  }

  // 清理过期缓存
  clearOldCache(currentPage) {
    const keepRange = this.preloadPages * 2 + 1;
    this.cache.forEach((_, key) => {
      const pageNum = parseInt(key.split('_')[1]);
      if (Math.abs(pageNum - currentPage) > keepRange) {
        this.cache.delete(key);
      }
    });
  }
}

// React Hook 封装
function usePagination(initialPage = 1) {
  const [currentPage, setCurrentPage] = useState(initialPage);
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const paginationRef = useRef(new SmartPagination());

  const loadPage = async (pageNum) => {
    setLoading(true);
    try {
      const pageData = await paginationRef.current.loadPage(pageNum);
      setData(pageData);
      setCurrentPage(pageNum);
    } finally {
      setLoading(false);
    }
  };

  return { data, loading, currentPage, loadPage };
}
```

> **总结**：智能分页结合缓存和预加载策略，在减少单次渲染压力的同时保证用户体验的流畅性。

### 3. **组件级优化**

```javascript
// React 组件优化
import React, { memo, useMemo, useCallback } from 'react';

// 行组件优化
const TableRow = memo(
  ({ data, onEdit, onDelete }) => {
    // 计算属性缓存
    const statusColor = useMemo(() => {
      switch (data.status) {
        case 'active':
          return '#52c41a';
        case 'inactive':
          return '#f5222d';
        default:
          return '#d9d9d9';
      }
    }, [data.status]);

    // 事件处理器缓存
    const handleEdit = useCallback(() => {
      onEdit(data.id);
    }, [data.id, onEdit]);

    const handleDelete = useCallback(() => {
      onDelete(data.id);
    }, [data.id, onDelete]);

    return (
      <tr>
        <td>{data.name}</td>
        <td>
          <span style={{ color: statusColor }}>{data.status}</span>
        </td>
        <td>
          <button onClick={handleEdit}>编辑</button>
          <button onClick={handleDelete}>删除</button>
        </td>
      </tr>
    );
  },
  (prevProps, nextProps) => {
    // 自定义比较函数
    return (
      prevProps.data.id === nextProps.data.id &&
      prevProps.data.status === nextProps.data.status &&
      prevProps.data.name === nextProps.data.name
    );
  }
);

// 事件委托优化
const TableContainer = ({ data, onEdit, onDelete }) => {
  const handleTableClick = useCallback(
    (e) => {
      const { target } = e;
      const row = target.closest('[data-row-id]');
      if (!row) return;

      const rowId = row.dataset.rowId;

      if (target.matches('[data-action="edit"]')) {
        onEdit(rowId);
      } else if (target.matches('[data-action="delete"]')) {
        onDelete(rowId);
      }
    },
    [onEdit, onDelete]
  );

  return (
    <table onClick={handleTableClick}>
      <tbody>
        {data.map((item) => (
          <tr key={item.id} data-row-id={item.id}>
            <td>{item.name}</td>
            <td>{item.status}</td>
            <td>
              <button data-action="edit">编辑</button>
              <button data-action="delete">删除</button>
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  );
};
```

> **总结**：通过 memo、useMemo、useCallback 和事件委托等优化手段减少不必要的重新渲染和事件监听器数量。

### 4. **图片优化策略**

```javascript
// 图片懒加载组件
const LazyImage = ({ src, alt, placeholder, className, width = 100 }) => {
  const [loaded, setLoaded] = useState(false);
  const [inView, setInView] = useState(false);
  const [error, setError] = useState(false);
  const imgRef = useRef(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setInView(true);
            observer.unobserve(entry.target);
          }
        });
      },
      {
        threshold: 0.1,
        rootMargin: '100px', // 提前 100px 开始加载
      }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => observer.disconnect();
  }, []);

  // 根据屏幕尺寸选择合适的图片
  const optimizedSrc = useMemo(() => {
    const pixelRatio = window.devicePixelRatio || 1;
    const targetWidth = Math.ceil(width * pixelRatio);
    const sizes = [50, 100, 200, 400, 800];
    const optimalSize = sizes.find((size) => size >= targetWidth) || sizes[sizes.length - 1];

    return `${src}?w=${optimalSize}&format=webp`;
  }, [src, width]);

  return (
    <div ref={imgRef} className={className}>
      {inView && !error && (
        <img
          src={optimizedSrc}
          alt={alt}
          onLoad={() => setLoaded(true)}
          onError={() => setError(true)}
          style={{
            opacity: loaded ? 1 : 0,
            transition: 'opacity 0.3s ease-in-out',
          }}
        />
      )}
      {(!inView || (!loaded && !error)) && <div className="image-placeholder">{placeholder || '📷'}</div>}
      {error && <div className="image-error">加载失败</div>}
    </div>
  );
};
```

> **总结**：通过懒加载、尺寸优化、格式转换等手段大幅减少图片资源的加载时间和内存占用。

## 数据管理优化

### 1. **状态管理优化**

```javascript
// 使用 Redux Toolkit 优化状态管理
import { createSlice, createAsyncThunk, createSelector } from '@reduxjs/toolkit';

// 异步数据加载
export const fetchTableData = createAsyncThunk(
  'table/fetchData',
  async ({ page, pageSize, filters }, { rejectWithValue }) => {
    try {
      const response = await fetch(`/api/table-data`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ page, pageSize, filters }),
      });

      if (!response.ok) {
        throw new Error('Failed to fetch data');
      }

      return await response.json();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const tableSlice = createSlice({
  name: 'table',
  initialState: {
    data: [],
    pagination: {
      current: 1,
      pageSize: 50,
      total: 0,
    },
    filters: {},
    loading: false,
    error: null,
    cache: {}, // 页面缓存
  },
  reducers: {
    setFilters: (state, action) => {
      state.filters = action.payload;
      state.pagination.current = 1; // 重置到第一页
    },
    setPageSize: (state, action) => {
      state.pagination.pageSize = action.payload;
      state.pagination.current = 1;
    },
    clearCache: (state) => {
      state.cache = {};
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchTableData.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchTableData.fulfilled, (state, action) => {
        const { data, pagination } = action.payload;
        const cacheKey = `${pagination.current}_${pagination.pageSize}`;

        state.data = data;
        state.pagination = { ...state.pagination, ...pagination };
        state.cache[cacheKey] = data; // 缓存数据
        state.loading = false;
      })
      .addCase(fetchTableData.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

// Memoized selectors
export const selectTableData = createSelector(
  (state) => state.table.data,
  (state) => state.table.filters,
  (data, filters) => {
    if (Object.keys(filters).length === 0) return data;

    return data.filter((item) => {
      return Object.entries(filters).every(([key, value]) => {
        if (!value) return true;
        return item[key]?.toString().toLowerCase().includes(value.toLowerCase());
      });
    });
  }
);
```

> **总结**：通过规范化的状态管理、数据缓存和选择器优化减少不必要的计算和渲染。

### 2. **数据预处理和缓存**

```javascript
// 数据预处理工具
class DataProcessor {
  constructor() {
    this.cache = new Map();
    this.computeCache = new Map();
  }

  // 数据标准化
  normalizeData(rawData) {
    const cacheKey = this.getCacheKey(rawData);

    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    const normalized = rawData.map((item) => ({
      ...item,
      // 预计算显示用的字段
      displayName: this.formatName(item.firstName, item.lastName),
      statusColor: this.getStatusColor(item.status),
      formattedDate: this.formatDate(item.createdAt),
      // 预生成操作权限
      canEdit: this.checkPermission(item, 'edit'),
      canDelete: this.checkPermission(item, 'delete'),
    }));

    this.cache.set(cacheKey, normalized);
    return normalized;
  }

  // 分组处理
  groupData(data, groupBy) {
    const cacheKey = `group_${groupBy}_${this.getCacheKey(data)}`;

    if (this.computeCache.has(cacheKey)) {
      return this.computeCache.get(cacheKey);
    }

    const grouped = data.reduce((groups, item) => {
      const key = item[groupBy];
      if (!groups[key]) {
        groups[key] = [];
      }
      groups[key].push(item);
      return groups;
    }, {});

    this.computeCache.set(cacheKey, grouped);
    return grouped;
  }

  // 辅助方法
  getCacheKey(data) {
    if (Array.isArray(data)) {
      return data.length > 0 ? `${data.length}_${data[0].id || 0}` : 'empty';
    }
    return JSON.stringify(data);
  }

  formatName(firstName, lastName) {
    return `${firstName} ${lastName}`.trim();
  }

  getStatusColor(status) {
    const colors = {
      active: '#52c41a',
      inactive: '#f5222d',
      pending: '#faad14',
    };
    return colors[status] || '#d9d9d9';
  }

  formatDate(dateString) {
    return new Date(dateString).toLocaleDateString();
  }

  checkPermission(item, action) {
    return item.permissions?.includes(action) || false;
  }
}
```

> **总结**：通过数据预处理和多层缓存机制避免重复计算，显著提升数据处理性能。

## 网络层优化

### 1. **API 优化策略**

```javascript
// 批量数据获取
class BatchDataLoader {
  constructor(options = {}) {
    this.batchSize = options.batchSize || 100;
    this.requestCache = new Map();
    this.pendingRequests = new Map();
  }

  async loadBatch(ids, force = false) {
    const cacheKey = ids.sort().join(',');

    // 检查缓存
    if (this.requestCache.has(cacheKey) && !force) {
      return this.requestCache.get(cacheKey);
    }

    // 检查是否有相同请求正在进行
    if (this.pendingRequests.has(cacheKey)) {
      return this.pendingRequests.get(cacheKey);
    }

    // 分批请求
    const batches = this.chunkArray(ids, this.batchSize);
    const promise = this.executeBatches(batches);

    this.pendingRequests.set(cacheKey, promise);

    try {
      const result = await promise;
      this.requestCache.set(cacheKey, result);
      return result;
    } finally {
      this.pendingRequests.delete(cacheKey);
    }
  }

  async executeBatches(batches) {
    const results = [];

    for (const batch of batches) {
      const response = await fetch('/api/batch-data', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ids: batch }),
      });

      const data = await response.json();
      results.push(...data);
    }

    return results;
  }

  chunkArray(array, size) {
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
}

// 请求去重和合并
class RequestDeduplicator {
  constructor() {
    this.pendingRequests = new Map();
  }

  async request(key, requestFn) {
    if (this.pendingRequests.has(key)) {
      return this.pendingRequests.get(key);
    }

    const promise = requestFn().finally(() => {
      this.pendingRequests.delete(key);
    });

    this.pendingRequests.set(key, promise);
    return promise;
  }
}

// 使用示例
const batchLoader = new BatchDataLoader({ batchSize: 50 });
const deduplicator = new RequestDeduplicator();

async function fetchTableData(page, filters) {
  const requestKey = `table_${page}_${JSON.stringify(filters)}`;

  return deduplicator.request(requestKey, async () => {
    const response = await fetch('/api/table-data', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ page, filters }),
    });
    return response.json();
  });
}
```

> **总结**：通过批量请求、请求去重和合并策略减少网络请求次数，提升数据加载效率。

## 用户体验优化

### 1. **骨架屏和加载状态**

```javascript
// 骨架屏组件
const TableSkeleton = ({ rows = 10, columns = 5 }) => {
  return (
    <div className="table-skeleton">
      {Array.from({ length: rows }).map((_, rowIndex) => (
        <div key={rowIndex} className="skeleton-row">
          {Array.from({ length: columns }).map((_, colIndex) => (
            <div key={colIndex} className="skeleton-cell">
              <div className="skeleton-content"></div>
            </div>
          ))}
        </div>
      ))}
    </div>
  );
};

// 渐进式加载
const ProgressiveTable = ({ data, loading, hasMore, onLoadMore }) => {
  const [displayData, setDisplayData] = useState([]);
  const [loadingMore, setLoadingMore] = useState(false);

  useEffect(() => {
    if (data.length > 0) {
      setDisplayData((prev) => [...prev, ...data]);
    }
  }, [data]);

  const handleLoadMore = async () => {
    setLoadingMore(true);
    try {
      await onLoadMore();
    } finally {
      setLoadingMore(false);
    }
  };

  if (loading && displayData.length === 0) {
    return <TableSkeleton />;
  }

  return (
    <div className="progressive-table">
      <table>
        <tbody>
          {displayData.map((item) => (
            <TableRow key={item.id} data={item} />
          ))}
        </tbody>
      </table>

      {loadingMore && (
        <div className="loading-more">
          <TableSkeleton rows={3} />
        </div>
      )}

      {hasMore && !loadingMore && (
        <button className="load-more-btn" onClick={handleLoadMore}>
          加载更多
        </button>
      )}
    </div>
  );
};
```

> **总结**：通过骨架屏、渐进式加载等交互方式提升用户等待体验，减少卡顿感知。

### 2. **响应式设计**

```javascript
// 响应式表格组件
const ResponsiveTable = ({ data, columns }) => {
  const [isMobile, setIsMobile] = useState(false);
  const [visibleColumns, setVisibleColumns] = useState(columns);

  useEffect(() => {
    const checkDevice = () => {
      const mobile = window.innerWidth < 768;
      setIsMobile(mobile);

      if (mobile) {
        // 移动端只显示关键列
        setVisibleColumns(columns.filter((col) => col.essential));
      } else {
        setVisibleColumns(columns);
      }
    };

    checkDevice();
    window.addEventListener('resize', checkDevice);
    return () => window.removeEventListener('resize', checkDevice);
  }, [columns]);

  if (isMobile) {
    return (
      <div className="mobile-table">
        {data.map((item) => (
          <div key={item.id} className="mobile-card">
            {visibleColumns.map((col) => (
              <div key={col.key} className="mobile-field">
                <span className="field-label">{col.title}:</span>
                <span className="field-value">{item[col.key]}</span>
              </div>
            ))}
          </div>
        ))}
      </div>
    );
  }

  return (
    <table className="desktop-table">
      <thead>
        <tr>
          {visibleColumns.map((col) => (
            <th key={col.key}>{col.title}</th>
          ))}
        </tr>
      </thead>
      <tbody>
        {data.map((item) => (
          <tr key={item.id}>
            {visibleColumns.map((col) => (
              <td key={col.key}>{item[col.key]}</td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
};
```

> **总结**：根据设备特性调整显示策略，在移动端使用卡片式布局减少渲染负担。

## 性能监控和优化

### 1. **性能指标监控**

```javascript
// 性能监控工具
class PerformanceMonitor {
  constructor() {
    this.metrics = {
      renderTime: [],
      scrollPerformance: [],
      memoryUsage: [],
      loadTime: [],
    };
  }

  // 监控渲染时间
  measureRender(name, fn) {
    const start = performance.now();
    const result = fn();
    const end = performance.now();

    this.metrics.renderTime.push({
      name,
      duration: end - start,
      timestamp: Date.now(),
    });

    return result;
  }

  // 监控滚动性能
  monitorScroll(element) {
    let lastScrollTime = 0;
    const scrollTimes = [];

    element.addEventListener('scroll', () => {
      const now = performance.now();
      if (lastScrollTime) {
        scrollTimes.push(now - lastScrollTime);
      }
      lastScrollTime = now;

      // 计算平均滚动响应时间
      if (scrollTimes.length > 10) {
        const avgTime = scrollTimes.reduce((a, b) => a + b) / scrollTimes.length;
        this.metrics.scrollPerformance.push({
          averageTime: avgTime,
          timestamp: Date.now(),
        });
        scrollTimes.length = 0;
      }
    });
  }

  // 监控内存使用
  monitorMemory() {
    if (performance.memory) {
      this.metrics.memoryUsage.push({
        used: performance.memory.usedJSHeapSize,
        total: performance.memory.totalJSHeapSize,
        limit: performance.memory.jsHeapSizeLimit,
        timestamp: Date.now(),
      });
    }
  }

  // 生成性能报告
  generateReport() {
    return {
      renderTime: {
        average: this.calculateAverage(this.metrics.renderTime, 'duration'),
        max: Math.max(...this.metrics.renderTime.map((m) => m.duration)),
        samples: this.metrics.renderTime.length,
      },
      scrollPerformance: {
        average: this.calculateAverage(this.metrics.scrollPerformance, 'averageTime'),
        samples: this.metrics.scrollPerformance.length,
      },
      memoryUsage: {
        current: this.metrics.memoryUsage[this.metrics.memoryUsage.length - 1],
        peak: this.metrics.memoryUsage.reduce((max, curr) => (curr.used > max.used ? curr : max), { used: 0 }),
      },
    };
  }

  calculateAverage(array, key) {
    if (array.length === 0) return 0;
    return array.reduce((sum, item) => sum + item[key], 0) / array.length;
  }
}

// 使用示例
const monitor = new PerformanceMonitor();

// 监控表格渲染
const TableWithMonitoring = ({ data }) => {
  return monitor.measureRender('table-render', () => (
    <table>
      {data.map((item) => (
        <tr key={item.id}>
          <td>{item.name}</td>
          <td>{item.status}</td>
        </tr>
      ))}
    </table>
  ));
};

// 定期生成报告
setInterval(() => {
  monitor.monitorMemory();
  const report = monitor.generateReport();
  console.log('Performance Report:', report);
}, 30000);
```

> **总结**：通过实时性能监控识别瓶颈点，为持续优化提供数据支撑。

## 总结

### **优化策略总览**

#### **核心技术**

- **虚拟滚动** - 只渲染可视区域，DOM 节点减少 90%+
- **智能分页** - 结合缓存和预加载，提升交互流畅度
- **组件优化** - memo、useMemo、useCallback 减少重渲染
- **图片懒加载** - 按需加载，减少初始资源压力

#### **数据层面**

- **状态管理** - 规范化数据流，避免冗余计算
- **数据预处理** - 预计算显示字段，缓存计算结果
- **网络优化** - 批量请求、去重合并、智能缓存
- **响应式适配** - 根据设备调整显示策略

#### **用户体验**

- **骨架屏** - 减少加载等待感知
- **渐进式加载** - 分批展示内容
- **性能监控** - 实时跟踪优化效果

### **实施建议**

#### **优先级排序**

1. **高优先级** - 虚拟滚动、分页优化（立即见效）
2. **中优先级** - 组件优化、图片懒加载（性能提升）
3. **低优先级** - 监控系统、高级缓存（长期优化）

#### **预期效果**

- **首屏渲染时间** - 减少 70-80%
- **内存占用** - 降低 60-70%
- **滚动流畅度** - 达到 60FPS
- **用户体验** - 卡顿感知大幅改善

通过系统性的优化策略组合，可以将大数据量表格从卡顿严重优化到流畅操作，同时保持功能的完整性和用户体验的友好性！
