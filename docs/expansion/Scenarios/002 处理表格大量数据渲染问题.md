---
title: 002 å¤„ç†è¡¨æ ¼å¤§é‡æ•°æ®æ¸²æŸ“é—®é¢˜
theme: solarized-dark
---

# å¤„ç†è¡¨æ ¼å¤§é‡æ•°æ®æ¸²æŸ“é—®é¢˜

## é—®é¢˜èƒŒæ™¯

åœ¨å¼€å‘åˆ—è¡¨ç³»ç»Ÿæ—¶ï¼ŒåˆæœŸå‡ åæ¡æ•°æ®è¡¨ç°è‰¯å¥½ï¼Œä½†éšç€ä¸šåŠ¡å‘å±•ï¼Œä¸€é¡µéœ€è¦å±•ç¤ºå‡ ç™¾è¡Œã€å‡ ååˆ—çš„æ•°æ®ï¼ŒåŒ…å«å›¾ç‰‡ã€çŠ¶æ€æ ‡ç­¾ã€å„ç§æ“ä½œæŒ‰é’®ç­‰å¤æ‚å…ƒç´ ï¼Œç”¨æˆ·åé¦ˆå¡é¡¿ä¸¥é‡ã€‚è¿™æ˜¯å…¸å‹çš„å¤§æ•°æ®é‡æ¸²æŸ“æ€§èƒ½é—®é¢˜ã€‚

## æ€§èƒ½é—®é¢˜åˆ†æ

### **ä¸»è¦æ€§èƒ½ç“¶é¢ˆ**

1. **DOM èŠ‚ç‚¹è¿‡å¤š** - å¤§é‡ DOM å…ƒç´ å¯¼è‡´æµè§ˆå™¨æ¸²æŸ“è´Ÿæ‹…é‡
2. **å†…å­˜å ç”¨é«˜** - æ‰€æœ‰æ•°æ®åŒæ—¶åŠ è½½åˆ°å†…å­˜
3. **é‡å¤æ¸²æŸ“** - ä¸å¿…è¦çš„ç»„ä»¶é‡æ–°æ¸²æŸ“
4. **èµ„æºåŠ è½½** - å¤§é‡å›¾ç‰‡åŒæ—¶åŠ è½½
5. **äº‹ä»¶ç›‘å¬å™¨è¿‡å¤š** - æ¯è¡Œéƒ½æœ‰å¤šä¸ªæ“ä½œæŒ‰é’®

### **æ€§èƒ½æŒ‡æ ‡æ£€æµ‹**

```javascript
// æ€§èƒ½ç›‘æ§ä»£ç 
function measurePerformance() {
  const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      console.log(`${entry.name}: ${entry.duration}ms`);
    }
  });

  observer.observe({ entryTypes: ['measure', 'navigation'] });

  // æµ‹é‡æ¸²æŸ“æ—¶é—´
  performance.mark('render-start');
  // ... æ¸²æŸ“ä»£ç 
  performance.mark('render-end');
  performance.measure('render-time', 'render-start', 'render-end');
}
```

> **æ€»ç»“**ï¼šé€šè¿‡æ€§èƒ½åˆ†æå·¥å…·è¯†åˆ«å…·ä½“çš„æ€§èƒ½ç“¶é¢ˆï¼Œä¸ºä¼˜åŒ–æä¾›æ•°æ®æ”¯æ’‘ã€‚

## æ ¸å¿ƒä¼˜åŒ–ç­–ç•¥

### 1. **è™šæ‹Ÿæ»šåŠ¨ï¼ˆVirtual Scrollingï¼‰**

è™šæ‹Ÿæ»šåŠ¨æ˜¯è§£å†³å¤§æ•°æ®é‡æ¸²æŸ“çš„æ ¸å¿ƒæŠ€æœ¯ï¼Œåªæ¸²æŸ“å¯è§†åŒºåŸŸå†…çš„æ•°æ®ã€‚

```javascript
// React è™šæ‹Ÿæ»šåŠ¨å®ç°ç¤ºä¾‹
import React, { useState, useEffect, useRef } from 'react';

const VirtualTable = ({ data, rowHeight = 50, containerHeight = 400 }) => {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef(null);

  // è®¡ç®—å¯è§†åŒºåŸŸ
  const startIndex = Math.floor(scrollTop / rowHeight);
  const endIndex = Math.min(startIndex + Math.ceil(containerHeight / rowHeight) + 1, data.length);

  // å¯è§†åŒºåŸŸæ•°æ®
  const visibleData = data.slice(startIndex, endIndex);

  const handleScroll = (e) => {
    setScrollTop(e.target.scrollTop);
  };

  return (
    <div
      ref={containerRef}
      style={{
        height: containerHeight,
        overflow: 'auto',
        position: 'relative',
      }}
      onScroll={handleScroll}
    >
      {/* å ä½å®¹å™¨ï¼Œç»´æŒæ»šåŠ¨æ¡é«˜åº¦ */}
      <div style={{ height: data.length * rowHeight, position: 'relative' }}>
        {/* å¯è§†åŒºåŸŸå†…å®¹ */}
        <div
          style={{
            position: 'absolute',
            top: startIndex * rowHeight,
            width: '100%',
          }}
        >
          {visibleData.map((item, index) => (
            <TableRow key={startIndex + index} data={item} style={{ height: rowHeight }} />
          ))}
        </div>
      </div>
    </div>
  );
};
```

> **æ€»ç»“**ï¼šè™šæ‹Ÿæ»šåŠ¨é€šè¿‡åªæ¸²æŸ“å¯è§†åŒºåŸŸå…ƒç´ ï¼Œå°† DOM èŠ‚ç‚¹æ•°é‡ä»æ•°åƒä¸ªé™ä½åˆ°å‡ åä¸ªï¼Œæ˜¾è‘—æå‡æ€§èƒ½ã€‚

### 2. **åˆ†é¡µå’Œæ‡’åŠ è½½**

```javascript
// æ™ºèƒ½åˆ†é¡µç­–ç•¥
class SmartPagination {
  constructor(options = {}) {
    this.pageSize = options.pageSize || 50;
    this.preloadPages = options.preloadPages || 1;
    this.cache = new Map();
    this.loading = new Set();
  }

  async loadPage(pageNum, forceRefresh = false) {
    const cacheKey = `page_${pageNum}`;

    // æ£€æŸ¥ç¼“å­˜
    if (this.cache.has(cacheKey) && !forceRefresh) {
      return this.cache.get(cacheKey);
    }

    // é˜²æ­¢é‡å¤åŠ è½½
    if (this.loading.has(pageNum)) {
      return new Promise((resolve) => {
        const checkLoading = () => {
          if (!this.loading.has(pageNum)) {
            resolve(this.cache.get(cacheKey));
          } else {
            setTimeout(checkLoading, 100);
          }
        };
        checkLoading();
      });
    }

    this.loading.add(pageNum);

    try {
      const data = await this.fetchData(pageNum);
      this.cache.set(cacheKey, data);

      // é¢„åŠ è½½ç›¸é‚»é¡µé¢
      this.preloadAdjacentPages(pageNum);

      return data;
    } finally {
      this.loading.delete(pageNum);
    }
  }

  async preloadAdjacentPages(currentPage) {
    const promises = [];
    for (let i = 1; i <= this.preloadPages; i++) {
      // é¢„åŠ è½½å‰åé¡µé¢
      if (currentPage - i > 0) {
        promises.push(this.loadPage(currentPage - i));
      }
      promises.push(this.loadPage(currentPage + i));
    }

    // ä¸ç­‰å¾…é¢„åŠ è½½å®Œæˆ
    Promise.allSettled(promises);
  }

  async fetchData(pageNum) {
    const response = await fetch(`/api/data?page=${pageNum}&size=${this.pageSize}`);
    return response.json();
  }

  // æ¸…ç†è¿‡æœŸç¼“å­˜
  clearOldCache(currentPage) {
    const keepRange = this.preloadPages * 2 + 1;
    this.cache.forEach((_, key) => {
      const pageNum = parseInt(key.split('_')[1]);
      if (Math.abs(pageNum - currentPage) > keepRange) {
        this.cache.delete(key);
      }
    });
  }
}

// React Hook å°è£…
function usePagination(initialPage = 1) {
  const [currentPage, setCurrentPage] = useState(initialPage);
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const paginationRef = useRef(new SmartPagination());

  const loadPage = async (pageNum) => {
    setLoading(true);
    try {
      const pageData = await paginationRef.current.loadPage(pageNum);
      setData(pageData);
      setCurrentPage(pageNum);
    } finally {
      setLoading(false);
    }
  };

  return { data, loading, currentPage, loadPage };
}
```

> **æ€»ç»“**ï¼šæ™ºèƒ½åˆ†é¡µç»“åˆç¼“å­˜å’Œé¢„åŠ è½½ç­–ç•¥ï¼Œåœ¨å‡å°‘å•æ¬¡æ¸²æŸ“å‹åŠ›çš„åŒæ—¶ä¿è¯ç”¨æˆ·ä½“éªŒçš„æµç•…æ€§ã€‚

### 3. **ç»„ä»¶çº§ä¼˜åŒ–**

```javascript
// React ç»„ä»¶ä¼˜åŒ–
import React, { memo, useMemo, useCallback } from 'react';

// è¡Œç»„ä»¶ä¼˜åŒ–
const TableRow = memo(
  ({ data, onEdit, onDelete }) => {
    // è®¡ç®—å±æ€§ç¼“å­˜
    const statusColor = useMemo(() => {
      switch (data.status) {
        case 'active':
          return '#52c41a';
        case 'inactive':
          return '#f5222d';
        default:
          return '#d9d9d9';
      }
    }, [data.status]);

    // äº‹ä»¶å¤„ç†å™¨ç¼“å­˜
    const handleEdit = useCallback(() => {
      onEdit(data.id);
    }, [data.id, onEdit]);

    const handleDelete = useCallback(() => {
      onDelete(data.id);
    }, [data.id, onDelete]);

    return (
      <tr>
        <td>{data.name}</td>
        <td>
          <span style={{ color: statusColor }}>{data.status}</span>
        </td>
        <td>
          <button onClick={handleEdit}>ç¼–è¾‘</button>
          <button onClick={handleDelete}>åˆ é™¤</button>
        </td>
      </tr>
    );
  },
  (prevProps, nextProps) => {
    // è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°
    return (
      prevProps.data.id === nextProps.data.id &&
      prevProps.data.status === nextProps.data.status &&
      prevProps.data.name === nextProps.data.name
    );
  }
);

// äº‹ä»¶å§”æ‰˜ä¼˜åŒ–
const TableContainer = ({ data, onEdit, onDelete }) => {
  const handleTableClick = useCallback(
    (e) => {
      const { target } = e;
      const row = target.closest('[data-row-id]');
      if (!row) return;

      const rowId = row.dataset.rowId;

      if (target.matches('[data-action="edit"]')) {
        onEdit(rowId);
      } else if (target.matches('[data-action="delete"]')) {
        onDelete(rowId);
      }
    },
    [onEdit, onDelete]
  );

  return (
    <table onClick={handleTableClick}>
      <tbody>
        {data.map((item) => (
          <tr key={item.id} data-row-id={item.id}>
            <td>{item.name}</td>
            <td>{item.status}</td>
            <td>
              <button data-action="edit">ç¼–è¾‘</button>
              <button data-action="delete">åˆ é™¤</button>
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  );
};
```

> **æ€»ç»“**ï¼šé€šè¿‡ memoã€useMemoã€useCallback å’Œäº‹ä»¶å§”æ‰˜ç­‰ä¼˜åŒ–æ‰‹æ®µå‡å°‘ä¸å¿…è¦çš„é‡æ–°æ¸²æŸ“å’Œäº‹ä»¶ç›‘å¬å™¨æ•°é‡ã€‚

### 4. **å›¾ç‰‡ä¼˜åŒ–ç­–ç•¥**

```javascript
// å›¾ç‰‡æ‡’åŠ è½½ç»„ä»¶
const LazyImage = ({ src, alt, placeholder, className, width = 100 }) => {
  const [loaded, setLoaded] = useState(false);
  const [inView, setInView] = useState(false);
  const [error, setError] = useState(false);
  const imgRef = useRef(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setInView(true);
            observer.unobserve(entry.target);
          }
        });
      },
      {
        threshold: 0.1,
        rootMargin: '100px', // æå‰ 100px å¼€å§‹åŠ è½½
      }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => observer.disconnect();
  }, []);

  // æ ¹æ®å±å¹•å°ºå¯¸é€‰æ‹©åˆé€‚çš„å›¾ç‰‡
  const optimizedSrc = useMemo(() => {
    const pixelRatio = window.devicePixelRatio || 1;
    const targetWidth = Math.ceil(width * pixelRatio);
    const sizes = [50, 100, 200, 400, 800];
    const optimalSize = sizes.find((size) => size >= targetWidth) || sizes[sizes.length - 1];

    return `${src}?w=${optimalSize}&format=webp`;
  }, [src, width]);

  return (
    <div ref={imgRef} className={className}>
      {inView && !error && (
        <img
          src={optimizedSrc}
          alt={alt}
          onLoad={() => setLoaded(true)}
          onError={() => setError(true)}
          style={{
            opacity: loaded ? 1 : 0,
            transition: 'opacity 0.3s ease-in-out',
          }}
        />
      )}
      {(!inView || (!loaded && !error)) && <div className="image-placeholder">{placeholder || 'ğŸ“·'}</div>}
      {error && <div className="image-error">åŠ è½½å¤±è´¥</div>}
    </div>
  );
};
```

> **æ€»ç»“**ï¼šé€šè¿‡æ‡’åŠ è½½ã€å°ºå¯¸ä¼˜åŒ–ã€æ ¼å¼è½¬æ¢ç­‰æ‰‹æ®µå¤§å¹…å‡å°‘å›¾ç‰‡èµ„æºçš„åŠ è½½æ—¶é—´å’Œå†…å­˜å ç”¨ã€‚

## æ•°æ®ç®¡ç†ä¼˜åŒ–

### 1. **çŠ¶æ€ç®¡ç†ä¼˜åŒ–**

```javascript
// ä½¿ç”¨ Redux Toolkit ä¼˜åŒ–çŠ¶æ€ç®¡ç†
import { createSlice, createAsyncThunk, createSelector } from '@reduxjs/toolkit';

// å¼‚æ­¥æ•°æ®åŠ è½½
export const fetchTableData = createAsyncThunk(
  'table/fetchData',
  async ({ page, pageSize, filters }, { rejectWithValue }) => {
    try {
      const response = await fetch(`/api/table-data`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ page, pageSize, filters }),
      });

      if (!response.ok) {
        throw new Error('Failed to fetch data');
      }

      return await response.json();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const tableSlice = createSlice({
  name: 'table',
  initialState: {
    data: [],
    pagination: {
      current: 1,
      pageSize: 50,
      total: 0,
    },
    filters: {},
    loading: false,
    error: null,
    cache: {}, // é¡µé¢ç¼“å­˜
  },
  reducers: {
    setFilters: (state, action) => {
      state.filters = action.payload;
      state.pagination.current = 1; // é‡ç½®åˆ°ç¬¬ä¸€é¡µ
    },
    setPageSize: (state, action) => {
      state.pagination.pageSize = action.payload;
      state.pagination.current = 1;
    },
    clearCache: (state) => {
      state.cache = {};
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchTableData.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchTableData.fulfilled, (state, action) => {
        const { data, pagination } = action.payload;
        const cacheKey = `${pagination.current}_${pagination.pageSize}`;

        state.data = data;
        state.pagination = { ...state.pagination, ...pagination };
        state.cache[cacheKey] = data; // ç¼“å­˜æ•°æ®
        state.loading = false;
      })
      .addCase(fetchTableData.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

// Memoized selectors
export const selectTableData = createSelector(
  (state) => state.table.data,
  (state) => state.table.filters,
  (data, filters) => {
    if (Object.keys(filters).length === 0) return data;

    return data.filter((item) => {
      return Object.entries(filters).every(([key, value]) => {
        if (!value) return true;
        return item[key]?.toString().toLowerCase().includes(value.toLowerCase());
      });
    });
  }
);
```

> **æ€»ç»“**ï¼šé€šè¿‡è§„èŒƒåŒ–çš„çŠ¶æ€ç®¡ç†ã€æ•°æ®ç¼“å­˜å’Œé€‰æ‹©å™¨ä¼˜åŒ–å‡å°‘ä¸å¿…è¦çš„è®¡ç®—å’Œæ¸²æŸ“ã€‚

### 2. **æ•°æ®é¢„å¤„ç†å’Œç¼“å­˜**

```javascript
// æ•°æ®é¢„å¤„ç†å·¥å…·
class DataProcessor {
  constructor() {
    this.cache = new Map();
    this.computeCache = new Map();
  }

  // æ•°æ®æ ‡å‡†åŒ–
  normalizeData(rawData) {
    const cacheKey = this.getCacheKey(rawData);

    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    const normalized = rawData.map((item) => ({
      ...item,
      // é¢„è®¡ç®—æ˜¾ç¤ºç”¨çš„å­—æ®µ
      displayName: this.formatName(item.firstName, item.lastName),
      statusColor: this.getStatusColor(item.status),
      formattedDate: this.formatDate(item.createdAt),
      // é¢„ç”Ÿæˆæ“ä½œæƒé™
      canEdit: this.checkPermission(item, 'edit'),
      canDelete: this.checkPermission(item, 'delete'),
    }));

    this.cache.set(cacheKey, normalized);
    return normalized;
  }

  // åˆ†ç»„å¤„ç†
  groupData(data, groupBy) {
    const cacheKey = `group_${groupBy}_${this.getCacheKey(data)}`;

    if (this.computeCache.has(cacheKey)) {
      return this.computeCache.get(cacheKey);
    }

    const grouped = data.reduce((groups, item) => {
      const key = item[groupBy];
      if (!groups[key]) {
        groups[key] = [];
      }
      groups[key].push(item);
      return groups;
    }, {});

    this.computeCache.set(cacheKey, grouped);
    return grouped;
  }

  // è¾…åŠ©æ–¹æ³•
  getCacheKey(data) {
    if (Array.isArray(data)) {
      return data.length > 0 ? `${data.length}_${data[0].id || 0}` : 'empty';
    }
    return JSON.stringify(data);
  }

  formatName(firstName, lastName) {
    return `${firstName} ${lastName}`.trim();
  }

  getStatusColor(status) {
    const colors = {
      active: '#52c41a',
      inactive: '#f5222d',
      pending: '#faad14',
    };
    return colors[status] || '#d9d9d9';
  }

  formatDate(dateString) {
    return new Date(dateString).toLocaleDateString();
  }

  checkPermission(item, action) {
    return item.permissions?.includes(action) || false;
  }
}
```

> **æ€»ç»“**ï¼šé€šè¿‡æ•°æ®é¢„å¤„ç†å’Œå¤šå±‚ç¼“å­˜æœºåˆ¶é¿å…é‡å¤è®¡ç®—ï¼Œæ˜¾è‘—æå‡æ•°æ®å¤„ç†æ€§èƒ½ã€‚

## ç½‘ç»œå±‚ä¼˜åŒ–

### 1. **API ä¼˜åŒ–ç­–ç•¥**

```javascript
// æ‰¹é‡æ•°æ®è·å–
class BatchDataLoader {
  constructor(options = {}) {
    this.batchSize = options.batchSize || 100;
    this.requestCache = new Map();
    this.pendingRequests = new Map();
  }

  async loadBatch(ids, force = false) {
    const cacheKey = ids.sort().join(',');

    // æ£€æŸ¥ç¼“å­˜
    if (this.requestCache.has(cacheKey) && !force) {
      return this.requestCache.get(cacheKey);
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰ç›¸åŒè¯·æ±‚æ­£åœ¨è¿›è¡Œ
    if (this.pendingRequests.has(cacheKey)) {
      return this.pendingRequests.get(cacheKey);
    }

    // åˆ†æ‰¹è¯·æ±‚
    const batches = this.chunkArray(ids, this.batchSize);
    const promise = this.executeBatches(batches);

    this.pendingRequests.set(cacheKey, promise);

    try {
      const result = await promise;
      this.requestCache.set(cacheKey, result);
      return result;
    } finally {
      this.pendingRequests.delete(cacheKey);
    }
  }

  async executeBatches(batches) {
    const results = [];

    for (const batch of batches) {
      const response = await fetch('/api/batch-data', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ids: batch }),
      });

      const data = await response.json();
      results.push(...data);
    }

    return results;
  }

  chunkArray(array, size) {
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
}

// è¯·æ±‚å»é‡å’Œåˆå¹¶
class RequestDeduplicator {
  constructor() {
    this.pendingRequests = new Map();
  }

  async request(key, requestFn) {
    if (this.pendingRequests.has(key)) {
      return this.pendingRequests.get(key);
    }

    const promise = requestFn().finally(() => {
      this.pendingRequests.delete(key);
    });

    this.pendingRequests.set(key, promise);
    return promise;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const batchLoader = new BatchDataLoader({ batchSize: 50 });
const deduplicator = new RequestDeduplicator();

async function fetchTableData(page, filters) {
  const requestKey = `table_${page}_${JSON.stringify(filters)}`;

  return deduplicator.request(requestKey, async () => {
    const response = await fetch('/api/table-data', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ page, filters }),
    });
    return response.json();
  });
}
```

> **æ€»ç»“**ï¼šé€šè¿‡æ‰¹é‡è¯·æ±‚ã€è¯·æ±‚å»é‡å’Œåˆå¹¶ç­–ç•¥å‡å°‘ç½‘ç»œè¯·æ±‚æ¬¡æ•°ï¼Œæå‡æ•°æ®åŠ è½½æ•ˆç‡ã€‚

## ç”¨æˆ·ä½“éªŒä¼˜åŒ–

### 1. **éª¨æ¶å±å’ŒåŠ è½½çŠ¶æ€**

```javascript
// éª¨æ¶å±ç»„ä»¶
const TableSkeleton = ({ rows = 10, columns = 5 }) => {
  return (
    <div className="table-skeleton">
      {Array.from({ length: rows }).map((_, rowIndex) => (
        <div key={rowIndex} className="skeleton-row">
          {Array.from({ length: columns }).map((_, colIndex) => (
            <div key={colIndex} className="skeleton-cell">
              <div className="skeleton-content"></div>
            </div>
          ))}
        </div>
      ))}
    </div>
  );
};

// æ¸è¿›å¼åŠ è½½
const ProgressiveTable = ({ data, loading, hasMore, onLoadMore }) => {
  const [displayData, setDisplayData] = useState([]);
  const [loadingMore, setLoadingMore] = useState(false);

  useEffect(() => {
    if (data.length > 0) {
      setDisplayData((prev) => [...prev, ...data]);
    }
  }, [data]);

  const handleLoadMore = async () => {
    setLoadingMore(true);
    try {
      await onLoadMore();
    } finally {
      setLoadingMore(false);
    }
  };

  if (loading && displayData.length === 0) {
    return <TableSkeleton />;
  }

  return (
    <div className="progressive-table">
      <table>
        <tbody>
          {displayData.map((item) => (
            <TableRow key={item.id} data={item} />
          ))}
        </tbody>
      </table>

      {loadingMore && (
        <div className="loading-more">
          <TableSkeleton rows={3} />
        </div>
      )}

      {hasMore && !loadingMore && (
        <button className="load-more-btn" onClick={handleLoadMore}>
          åŠ è½½æ›´å¤š
        </button>
      )}
    </div>
  );
};
```

> **æ€»ç»“**ï¼šé€šè¿‡éª¨æ¶å±ã€æ¸è¿›å¼åŠ è½½ç­‰äº¤äº’æ–¹å¼æå‡ç”¨æˆ·ç­‰å¾…ä½“éªŒï¼Œå‡å°‘å¡é¡¿æ„ŸçŸ¥ã€‚

### 2. **å“åº”å¼è®¾è®¡**

```javascript
// å“åº”å¼è¡¨æ ¼ç»„ä»¶
const ResponsiveTable = ({ data, columns }) => {
  const [isMobile, setIsMobile] = useState(false);
  const [visibleColumns, setVisibleColumns] = useState(columns);

  useEffect(() => {
    const checkDevice = () => {
      const mobile = window.innerWidth < 768;
      setIsMobile(mobile);

      if (mobile) {
        // ç§»åŠ¨ç«¯åªæ˜¾ç¤ºå…³é”®åˆ—
        setVisibleColumns(columns.filter((col) => col.essential));
      } else {
        setVisibleColumns(columns);
      }
    };

    checkDevice();
    window.addEventListener('resize', checkDevice);
    return () => window.removeEventListener('resize', checkDevice);
  }, [columns]);

  if (isMobile) {
    return (
      <div className="mobile-table">
        {data.map((item) => (
          <div key={item.id} className="mobile-card">
            {visibleColumns.map((col) => (
              <div key={col.key} className="mobile-field">
                <span className="field-label">{col.title}:</span>
                <span className="field-value">{item[col.key]}</span>
              </div>
            ))}
          </div>
        ))}
      </div>
    );
  }

  return (
    <table className="desktop-table">
      <thead>
        <tr>
          {visibleColumns.map((col) => (
            <th key={col.key}>{col.title}</th>
          ))}
        </tr>
      </thead>
      <tbody>
        {data.map((item) => (
          <tr key={item.id}>
            {visibleColumns.map((col) => (
              <td key={col.key}>{item[col.key]}</td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
};
```

> **æ€»ç»“**ï¼šæ ¹æ®è®¾å¤‡ç‰¹æ€§è°ƒæ•´æ˜¾ç¤ºç­–ç•¥ï¼Œåœ¨ç§»åŠ¨ç«¯ä½¿ç”¨å¡ç‰‡å¼å¸ƒå±€å‡å°‘æ¸²æŸ“è´Ÿæ‹…ã€‚

## æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–

### 1. **æ€§èƒ½æŒ‡æ ‡ç›‘æ§**

```javascript
// æ€§èƒ½ç›‘æ§å·¥å…·
class PerformanceMonitor {
  constructor() {
    this.metrics = {
      renderTime: [],
      scrollPerformance: [],
      memoryUsage: [],
      loadTime: [],
    };
  }

  // ç›‘æ§æ¸²æŸ“æ—¶é—´
  measureRender(name, fn) {
    const start = performance.now();
    const result = fn();
    const end = performance.now();

    this.metrics.renderTime.push({
      name,
      duration: end - start,
      timestamp: Date.now(),
    });

    return result;
  }

  // ç›‘æ§æ»šåŠ¨æ€§èƒ½
  monitorScroll(element) {
    let lastScrollTime = 0;
    const scrollTimes = [];

    element.addEventListener('scroll', () => {
      const now = performance.now();
      if (lastScrollTime) {
        scrollTimes.push(now - lastScrollTime);
      }
      lastScrollTime = now;

      // è®¡ç®—å¹³å‡æ»šåŠ¨å“åº”æ—¶é—´
      if (scrollTimes.length > 10) {
        const avgTime = scrollTimes.reduce((a, b) => a + b) / scrollTimes.length;
        this.metrics.scrollPerformance.push({
          averageTime: avgTime,
          timestamp: Date.now(),
        });
        scrollTimes.length = 0;
      }
    });
  }

  // ç›‘æ§å†…å­˜ä½¿ç”¨
  monitorMemory() {
    if (performance.memory) {
      this.metrics.memoryUsage.push({
        used: performance.memory.usedJSHeapSize,
        total: performance.memory.totalJSHeapSize,
        limit: performance.memory.jsHeapSizeLimit,
        timestamp: Date.now(),
      });
    }
  }

  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
  generateReport() {
    return {
      renderTime: {
        average: this.calculateAverage(this.metrics.renderTime, 'duration'),
        max: Math.max(...this.metrics.renderTime.map((m) => m.duration)),
        samples: this.metrics.renderTime.length,
      },
      scrollPerformance: {
        average: this.calculateAverage(this.metrics.scrollPerformance, 'averageTime'),
        samples: this.metrics.scrollPerformance.length,
      },
      memoryUsage: {
        current: this.metrics.memoryUsage[this.metrics.memoryUsage.length - 1],
        peak: this.metrics.memoryUsage.reduce((max, curr) => (curr.used > max.used ? curr : max), { used: 0 }),
      },
    };
  }

  calculateAverage(array, key) {
    if (array.length === 0) return 0;
    return array.reduce((sum, item) => sum + item[key], 0) / array.length;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const monitor = new PerformanceMonitor();

// ç›‘æ§è¡¨æ ¼æ¸²æŸ“
const TableWithMonitoring = ({ data }) => {
  return monitor.measureRender('table-render', () => (
    <table>
      {data.map((item) => (
        <tr key={item.id}>
          <td>{item.name}</td>
          <td>{item.status}</td>
        </tr>
      ))}
    </table>
  ));
};

// å®šæœŸç”ŸæˆæŠ¥å‘Š
setInterval(() => {
  monitor.monitorMemory();
  const report = monitor.generateReport();
  console.log('Performance Report:', report);
}, 30000);
```

> **æ€»ç»“**ï¼šé€šè¿‡å®æ—¶æ€§èƒ½ç›‘æ§è¯†åˆ«ç“¶é¢ˆç‚¹ï¼Œä¸ºæŒç»­ä¼˜åŒ–æä¾›æ•°æ®æ”¯æ’‘ã€‚

## æ€»ç»“

### **ä¼˜åŒ–ç­–ç•¥æ€»è§ˆ**

#### **æ ¸å¿ƒæŠ€æœ¯**

- **è™šæ‹Ÿæ»šåŠ¨** - åªæ¸²æŸ“å¯è§†åŒºåŸŸï¼ŒDOM èŠ‚ç‚¹å‡å°‘ 90%+
- **æ™ºèƒ½åˆ†é¡µ** - ç»“åˆç¼“å­˜å’Œé¢„åŠ è½½ï¼Œæå‡äº¤äº’æµç•…åº¦
- **ç»„ä»¶ä¼˜åŒ–** - memoã€useMemoã€useCallback å‡å°‘é‡æ¸²æŸ“
- **å›¾ç‰‡æ‡’åŠ è½½** - æŒ‰éœ€åŠ è½½ï¼Œå‡å°‘åˆå§‹èµ„æºå‹åŠ›

#### **æ•°æ®å±‚é¢**

- **çŠ¶æ€ç®¡ç†** - è§„èŒƒåŒ–æ•°æ®æµï¼Œé¿å…å†—ä½™è®¡ç®—
- **æ•°æ®é¢„å¤„ç†** - é¢„è®¡ç®—æ˜¾ç¤ºå­—æ®µï¼Œç¼“å­˜è®¡ç®—ç»“æœ
- **ç½‘ç»œä¼˜åŒ–** - æ‰¹é‡è¯·æ±‚ã€å»é‡åˆå¹¶ã€æ™ºèƒ½ç¼“å­˜
- **å“åº”å¼é€‚é…** - æ ¹æ®è®¾å¤‡è°ƒæ•´æ˜¾ç¤ºç­–ç•¥

#### **ç”¨æˆ·ä½“éªŒ**

- **éª¨æ¶å±** - å‡å°‘åŠ è½½ç­‰å¾…æ„ŸçŸ¥
- **æ¸è¿›å¼åŠ è½½** - åˆ†æ‰¹å±•ç¤ºå†…å®¹
- **æ€§èƒ½ç›‘æ§** - å®æ—¶è·Ÿè¸ªä¼˜åŒ–æ•ˆæœ

### **å®æ–½å»ºè®®**

#### **ä¼˜å…ˆçº§æ’åº**

1. **é«˜ä¼˜å…ˆçº§** - è™šæ‹Ÿæ»šåŠ¨ã€åˆ†é¡µä¼˜åŒ–ï¼ˆç«‹å³è§æ•ˆï¼‰
2. **ä¸­ä¼˜å…ˆçº§** - ç»„ä»¶ä¼˜åŒ–ã€å›¾ç‰‡æ‡’åŠ è½½ï¼ˆæ€§èƒ½æå‡ï¼‰
3. **ä½ä¼˜å…ˆçº§** - ç›‘æ§ç³»ç»Ÿã€é«˜çº§ç¼“å­˜ï¼ˆé•¿æœŸä¼˜åŒ–ï¼‰

#### **é¢„æœŸæ•ˆæœ**

- **é¦–å±æ¸²æŸ“æ—¶é—´** - å‡å°‘ 70-80%
- **å†…å­˜å ç”¨** - é™ä½ 60-70%
- **æ»šåŠ¨æµç•…åº¦** - è¾¾åˆ° 60FPS
- **ç”¨æˆ·ä½“éªŒ** - å¡é¡¿æ„ŸçŸ¥å¤§å¹…æ”¹å–„

é€šè¿‡ç³»ç»Ÿæ€§çš„ä¼˜åŒ–ç­–ç•¥ç»„åˆï¼Œå¯ä»¥å°†å¤§æ•°æ®é‡è¡¨æ ¼ä»å¡é¡¿ä¸¥é‡ä¼˜åŒ–åˆ°æµç•…æ“ä½œï¼ŒåŒæ—¶ä¿æŒåŠŸèƒ½çš„å®Œæ•´æ€§å’Œç”¨æˆ·ä½“éªŒçš„å‹å¥½æ€§ï¼
